import osimport discordimport sysfrom discord.ext import commandsfrom io import BytesIOimport reimport asyncioimport timeitimport ioimport textwrapfrom contextlib import redirect_stdoutimport tracebackclass OwnerCommands:    def __init__(self, bot):        self.bot = bot        self._last_result = None    @commands.command(name="restart")    @commands.is_owner()    async def restart_cmd(self, ctx):        """Restarts the bot (only works on windows)"""        msg = await ctx.send("I will now restart!")        # gets message channel and id in order to edit the message later        if msg.guild.id is None:            channel_id = ctx.author.id        else:            channel_id = msg.channel.id        # removes files if they are already existing        if os.path.exists("restart.bat"):            os.remove("restart.bat")        if os.path.exists("message_id.json"):            os.remove("message_id.json")        # sets everything up        self.save_message_id(msg.id, channel_id)        self.create_bat()  # reason why it only works with Windows        self.start_bat()        await self.bot.logout()    @staticmethod    def create_bat():        bat_code = f"@ECHO OFF\ntimeout /t 3 /nobreak>nul\nstart {sys.path[5]}\\python.exe main_bot.py"        with open("restart.bat", "w") as file:            file.write(bat_code)        return    @staticmethod    def start_bat():        path = os.getcwd()        os.startfile(filepath=f"{path}\\restart.bat")        return    @staticmethod    def save_message_id(message_id, channel_id):        message_id = str(message_id)        channel_id = str(channel_id)        with open("message_id.json", "w") as file_:            file_.write('{"channel_id": "' + channel_id + '", "message_id": "' + message_id + '"}')    @commands.command(name="shutdown")    @commands.is_owner()    async def shutdown_cmd(self, ctx):        """Shutdown the bot"""        # logs out and closes the bot        await ctx.send("I will shutdown now!")        await self.bot.logout()    @commands.command(name="reload")    @commands.is_owner()    async def reload_cmd(self, ctx, *, module: str=None):        """Reload a specified module"""        # checks if module even is something        if module is None:            return await ctx.send("Please specify a module.")        # makes the module valid        if not module.__contains__("cmd_"):            module = "cmd_" + module        if not module.__contains__(".py"):            module = f"{module}.py"        module = module.replace(" ", "_")        # searches if there is a modules path if yes it uses it abd then unloads and loads the extension        if os.path.exists("./modules"):            if os.path.exists(f"./modules/{module}"):                discord_module = f"modules.{module}"                self.reload(discord_module)                return await ctx.send(f"Successfully reloaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")        else:            if os.path.exists(f"./{module}"):                self.reload(module)                return await ctx.send(f"Successfully reloaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")    def reload(self, module):        module = module.replace(".py", "")        self.bot.unload_extension(module)        self.bot.load_extension(module)        return    @commands.command(name="unload")    @commands.is_owner()    async def unload_cmd(self, ctx, *, module: str=None):        """Unloads a specified module"""        # checks if module is something        if module is None:            return await ctx.send("Please specify a module.")        # makes module format valid        if not module.__contains__("cmd_"):            module = "cmd_" + module        if not module.__contains__(".py"):            module = f"{module}.py"        module = module.replace(" ", "_")        # checks if there is a modules path and uses it if its there and then unloads the extension        if os.path.exists("./modules"):            if os.path.exists(f"./modules/{module}"):                discord_module = f"modules.{module}"                self.bot.unload_extension(discord_module.replace(".py", ""))                return await ctx.send(f"Successfully unloaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")        else:            if os.path.exists(f"./{module}"):                self.bot.unload_extension(module.replace(".py", ""))                return await ctx.send(f"Successfully unloaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")    @commands.command(name="load")    @commands.is_owner()    async def load_cmd(self, ctx, *, module: str = None):        """Loads a specified module"""        # checks if module is something        if module is None:            return await ctx.send("Please specify a module.")        # makes module format valid        if not module.__contains__("cmd_"):            module = "cmd_" + module        if not module.__contains__(".py"):            module = f"{module}.py"        module = module.replace(" ", "_")        # checks if there is a modules path and uses it if its there and then loads the extension        if os.path.exists("./modules"):            if os.path.exists(f"./modules/{module}"):                discord_module = f"modules.{module}"                self.bot.load_extension(discord_module.replace(".py", ""))                return await ctx.send(f"Successfully loaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")        else:            if os.path.exists(f"./{module}"):                self.bot.load_extension(module.replace(".py", ""))                return await ctx.send(f"Successfully loaded the {module} module.")            else:                return await ctx.send("Please specify a valid module.")    @commands.command(name="update", aliases=["add"])    @commands.is_owner()    async def update_cmd(self, ctx):        """Update a file in the bot."""        # specify the file        attachment = ctx.message.attachments[0]        filename = attachment.filename        # fix the format        if not filename.__contains__("cmd_"):            filename = "cmd_" + filename        # make it a "file"        bytesio = BytesIO()        # saves the code        await attachment.save(fp=bytesio)        code = bytesio.read().decode('utf-8')        # checks if the modules path is there, if yes it  gets used        if os.path.exists("./modules"):            filename_ = filename            filename = f"./modules/{filename}"        if os.path.exists(filename):            with open(filename, "r") as file:                old_code = file.read()            with open(f"old_{filename_}", "w") as file:                file.write(old_code)        with open(filename, "w") as file:            file.write(code)        await ctx.send("Successfully updated!")    @commands.command(name="unupdate", aliases=["downgrade"])    @commands.is_owner()    async def unupdate_cmd(self, ctx, *, filename: str=None):        """Downgrades a specified file from the bot."""        # checks if there is a specified filename        if filename is None:            return await ctx.send("Please specify a valid module/filename.")        # fixes format        if not filename.__contains__(".py"):            filename = filename + ".py"        if not filename.__contains__("cmd_"):            filename = "cmd_" + filename        # makes sure there even is a old version        if os.path.exists(f"old_{filename}"):            with open(f"old_{filename}", "r") as file:                code = file.read()                file.close()            # if the modules path exists it uses it            if os.path.exists("./modules") and os.path.exists(f"./modules/{filename}"):                with open(f"./modules/{filename}", "w") as file:                    file.write(code)                    file.close()            else:                if os.path.exists(f"./{filename}"):                    with open(f"./{filename}", "w") as file:                        file.write(code)                        file.close()                else:                    return await ctx.send("Please specify a valid filename!")            return await ctx.send("Successfully downgraded again!")        else:            return await ctx.send("I couldn't find an old version of this file.")    @commands.command(name="eval")    @commands.is_owner()    async def eval_code_cmd(self, ctx, *, code: str=None):        """Evaluates code"""        env = {            'bot': self.bot,            'ctx': ctx,            'channel': ctx.message.channel,            'author': ctx.message.author,            'guild': ctx.message.guild,            'message': ctx.message,            '_': self._last_result        }        env.update(globals())        body = self.cleanup_code(code)        stdout = io.StringIO()        to_compile = f'async def func():\n{textwrap.indent(body, "  ")}'        try:            exec(to_compile, env)        except Exception as e:            return await ctx.send(f'```py\n{e.__class__.__name__}: {e}\n```')        func = env['func']        try:            with redirect_stdout(stdout):                ret = await func()                time_taken = timeit.timeit(to_compile)        except Exception as e:            value = stdout.getvalue()            await ctx.send(f'```py\n{value}{traceback.format_exc()}\n```')        else:            value = stdout.getvalue()            try:                await ctx.message.add_reaction('\u2705')            except:                pass            if ret is None:                if value:                    await ctx.send(f'```py\n{value}\n```\nFinished in {round(time_taken, 2)} seconds.')            else:                self._last_result = ret                await ctx.send(f'```py\n{value}{ret}\n```')    @staticmethod    def cleanup_code(content):        # remove ```py\n```        if content.startswith('```') and content.endswith('```'):            return '\n'.join(content.split('\n')[1:-1])        # remove `foo`        return content.strip('` \n')    @commands.command(name="setgame")    @commands.is_owner()    async def setgame_cmd(self, ctx, type_=None, *, game):        """Changes the current playing status"""        if type_ is None:            return await ctx.send(f"Please follow the format: `{ctx.prefix}{ctx.command} <game type> <game>`")        try:            game = discord.Game(game)            type_ = type_.lower()            if type_ not in ["idle", "offline", "online", "dnd"]:                game = type_ + " " + game                type_ = "online"            await self.bot.change_presence(activity=game, status=eval(f"discord.Status.{type_}"))            await ctx.send("Successfully changed my playing status!")        except Exception as e:            await ctx.send(f"Something didn't go quite right: {e}")    @staticmethod    async def __error(ctx, error):        if isinstance(error, IndexError):            return await ctx.send("An error occurred! Please make sure that you followed the format.", delete_after=10)        elif isinstance(error, commands.MissingPermissions):            return        elif isinstance(error, commands.NoPrivateMessage):            await ctx.message.add_reaction("❌")            return await ctx.send("You can't use this command here.")        elif isinstance(error, commands.NotOwner):            return        print(f"An error occurred: Command: {ctx.command}\nError: {traceback.format_exc()}")        await ctx.send(f"An error occurred: {error}")def setup(bot):    bot.add_cog(OwnerCommands(bot))